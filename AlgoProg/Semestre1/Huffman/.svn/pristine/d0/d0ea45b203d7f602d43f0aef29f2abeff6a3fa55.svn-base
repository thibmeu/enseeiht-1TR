#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include "compress.h"

static inline void loadBar(int x, int n, int r, int w)
{
    // Only update r times.
    if ( x % (n/r +1) != 0 ) return;
 
    // Calculuate the ratio of complete-to-incomplete.
    float ratio = x/(float)n;
    int   c     = ratio * w;
 
    // Show the percentage complete.
    printf("%3d%% [", (int)(ratio*100));
 
    // Show the load bar.
    for (int x=0; x<c; x++)
       printf("=");
 
    for (int x=c; x<w; x++)
       printf(" ");
 
    printf("]\r");
    fflush(stdout);
}

void print_tab_Couple(Couple* couples, int size)
{
	for (int iCouple = 0; iCouple < size; iCouple++)
		printf("%c: %lu\n", couples[iCouple].value, couples[iCouple].freq);
}

void init_freq(Couple* couples)
{
	for (int iCouple = 0; iCouple < UCHAR_MAX; iCouple++)
		init_Couple(&couples[iCouple], 0, (unsigned char) iCouple);
}

int frequence(FILE* fichier, Couple* couples)
{
	FILE* copieFichier = fichier; //on effectue une copie du pointeur pour ne pas le modifier et avoir à ré-ouvrir le fichier
	int sizeFile = 0;
	while (!feof(copieFichier))
	{
		unsigned char iCarac;
		fscanf(copieFichier, "%c", &iCarac);
		couples[iCarac].freq += 1;
		sizeFile++;
	}
	
	return sizeFile;
}

void tri_Couple(Couple* couples)
{
	qsort(couples, UCHAR_MAX, sizeof(Couple), compar_Couple);
}

void add_couple_List_Tree(List list, Couple couple)
//Ajoute un couple a une liste d'arbre
{
	Tree treeTampon;
	init_Tree(&treeTampon);
	treeTampon->couple = couple;
	
	puts("treeTampon add couple...:");
	print_Tree(treeTampon);
	
	add_List(list, treeTampon);
	
	puts("list add couple...");
	print_list_tree(list);
	
	destruct_Tree(&treeTampon);
}

size_t build_Tree(Couple* couples, Tree* tree)
{
	//on passe toutes les cellules ou la frequence est nulle
	int iCouple = 0;
	while (couples[iCouple].freq == 0)
		iCouple++;
	size_t sizeTree = UCHAR_MAX - iCouple;
	
	//on transforme la liste de cellules en liste d'arbres a un noeud
	Tree trees[sizeTree];
	for(int iTree = 0; iTree < sizeTree; iTree++)
	{
		init_Tree(trees + iTree);
		couple_to_Tree(&(trees[iTree]), couples[iCouple + iTree]);
	}
	
	fusion_tab_Tree(trees, sizeTree);
	
	//On recupere le seul arbre de la liste qui est l'arbre fusionne
	*tree = trees[sizeTree - 1];
	
	return sizeTree;
}

void description_Tree(Tree tree, Binary description, Value** caracs)
{
	//print_hexa_Binary(description);
	if (tree != NULL)
	{
		if (is_leaf_Tree(tree))
		{
			**caracs = (unsigned char)tree->couple.value;
			(*caracs)++;
		}
		
		add_zero_Binary(description); //ajouter un zero en fin de sequence binaire
		description_Tree(tree->left, description, caracs);
		
		if (!is_leaf_Tree(tree))
			add_one_Binary(description); //ajouteur un 1 en fin de sequence binaire
		
		description_Tree(tree->right, description, caracs);
		
		if (!is_leaf_Tree(tree))
			add_one_Binary(description); //ajouteur un 1 en fin de sequence binaire
	}
}

int indice_tableau(Value elmt, Value* tableau, size_t sizeTab)
{
	for (int i = 0; i < sizeTab; i++)
	{
		if (tableau[i] == elmt)
			return i;
	}
	return -1;
}

void mise_en_forme_description(Binary descriptionTree)
{	
	//print_Binary(descriptionTree);
	while (back_Bit_Byte(descriptionTree)) //back_Bit_Byte ne fonctionne pas
	{
		right_shift_Binary(descriptionTree, 1);
		//print_Binary(descriptionTree);
	}
		
	add_one_Binary(descriptionTree);
}

void write_forhead(FILE* output, size_t sizeText, size_t sizeTree, Value* caracs)
{
	fprintf(output, "%lu", sizeText);
	fprintf(output, "%c", (unsigned char)sizeTree);
	for (int iChar = 0; iChar < sizeTree; iChar++)
		fprintf(output, "%c", caracs[iChar]);
}

void write_body_compress(FILE* input, FILE* output, Binary descriptionTree, Binary* tableCorresp, Value* caracs, size_t sizeTree, size_t sizeText)
{
	Binary tamponBinary = descriptionTree;
	write_Binary(tamponBinary, output);
	
	int iChar = 0;
	do
	{
		loadBar(iChar, sizeText, (int)sqrt(sizeText)+1, 50);
		unsigned char readCaractere;
		fscanf(input, "%c", &readCaractere);
		
		Binary binaryCaract;
		binaryCaract = tableCorresp[(int)readCaractere];
		
		concatenate_Binary(tamponBinary, binaryCaract);
		write_Binary(tamponBinary, output);
		iChar++;
	} while (!feof(input));
	
	//on cloture alors le texte
	Binary zeroBinary = zero_Binary();
	
	while (tamponBinary != zeroBinary && tamponBinary->size < 8)
		add_zero_Binary(tamponBinary);
		
	fprintf(output, "%c", (char) 3);
	
	destruct_Binary(&zeroBinary);
}

void compress(FILE* input, FILE* output)
{	
	Couple couples[UCHAR_MAX];
	init_freq(couples);
	
	int sizeFile = frequence(input, couples);
	rewind(input);
	
	tri_Couple(couples);
	
	Tree tree;
	size_t sizeTree = build_Tree(couples, &tree);
	
	Binary descriptionTree = un_Binary();
	Value* caracs = malloc(sizeof(Value)*sizeTree);
	Value* parcoursCarac = caracs;
	description_Tree(tree, descriptionTree, &parcoursCarac); //établit la description de l'arbre et la liste (ordonnee) des caractères qui le compose
	print_hexa_Binary(descriptionTree);
	
	mise_en_forme_description(descriptionTree); //s'assure que descriptionTree termine par un seul 1

	Binary tableCorresp[UCHAR_MAX]; //va contenir la table de correspondance (caractère -> code de huffman)
	for(int i=0; i< UCHAR_MAX; i++)
		init_Binary(tableCorresp+i);
	
	construct_table_corresp(tree, tableCorresp, caracs, sizeTree, 0, 0); //on construit la table de correspondance
	
	write_forhead(output, sizeFile, sizeTree, caracs);
	write_body_compress(input, output, descriptionTree, tableCorresp, caracs, sizeTree, sizeFile);
	
	print_table_corresp(tableCorresp);
	
	for(int i=0; i< UCHAR_MAX; i++)
		destruct_Binary(&(tableCorresp[i]));
	
	print_Tree(tree);
	
	free(caracs);
	destruct_Binary(&descriptionTree);
	destruct_Tree(&tree);
}
