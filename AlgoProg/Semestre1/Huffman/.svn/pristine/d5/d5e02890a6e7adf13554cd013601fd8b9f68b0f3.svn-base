#include <stdio.h>
#include <stdlib.h>

#include "uncompress.h"

void print_Byte(Byte byte, size_t sizeByte)
{
	if (sizeByte > 0)
	{
		if (first_bit_Byte(byte))
			printf("1");
		else
			printf("0");
		print_Byte(byte << 1, sizeByte - 1);
	}
	else
		printf("\n");
}

bool first_bit_Byte(Byte byte)
{
	Byte testByte = byte >> 7;
	return (testByte == (char)1)?true:false;
}

void pop_back_Byte(Byte* byte)
{
	*byte = *byte << 1;
}

void add_empty_subTree(Tree tree, bool right)
{
	Tree newTree;
	init_Tree(&newTree);
	add_subTree(tree, newTree, right);
}

void read_forhead(FILE* input, size_t* sizeText, char* sizeTree, Value** caracsTree)
{
	fscanf(input, "%lu", sizeText);
	fscanf(input, "%c", sizeTree);
	int sizeT = (int) *sizeTree; 
	*caracsTree = malloc(sizeof(Value)*sizeT);
	for (int iCarac = 0; iCarac < sizeT; iCarac++)
		fscanf(input, "%c", (*caracsTree + iCarac));
}

void update_byte(Byte* byte, size_t* sizeByte, FILE* file)
{
	if (*sizeByte == 0)
	{
		fscanf(file, "%c", byte);
		*sizeByte = (*sizeByte) + 8;
		print_Byte(*byte, *sizeByte);
		//printf("sizeByte: %lu\n", *sizeByte);
	}
	pop_back_Byte(byte);
	*sizeByte = (*sizeByte) - 1;
}

void reconstruct_Tree(FILE* input, Tree tree, Byte* byte, size_t* sizeByte, size_t sizeTree, size_t* nbLeaf, Value* caracsTree)
{
	printf("\n\n%lu/%lu, sizeByte: %lu\n", *nbLeaf, sizeTree, *sizeByte);
	print_Byte(*byte, *sizeByte);
	if (*nbLeaf < sizeTree)
	{
		if (!first_bit_Byte(*byte))
		{
			puts("zero");
			update_byte(byte, sizeByte, input);
			
			add_empty_subTree(tree, false);
			reconstruct_Tree(input, tree->left, byte, sizeByte, sizeTree, nbLeaf, caracsTree);
			
			printf("Passage Ã  droite\n");
			
			add_empty_subTree(tree, true);
			reconstruct_Tree(input, tree->right, byte, sizeByte, sizeTree, nbLeaf, caracsTree);
		}
		else
		{
			puts("un");
			update_byte(byte, sizeByte, input);
			update_byte(byte, sizeByte, input);
			print_Tree(tree);
			if (is_leaf_Tree(tree))
			{
				tree->couple.value = caracsTree[*nbLeaf];
				printf("%c\n", tree->couple.value);
				(*nbLeaf)++;
			}
		}
	}
}
