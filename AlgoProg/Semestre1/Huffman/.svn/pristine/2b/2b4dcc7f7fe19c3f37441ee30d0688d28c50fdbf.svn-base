#include <stdio.h>
#include <stdlib.h>

#include "uncompress.h"

void print_Byte(Byte byte, size_t sizeByte)
{
	if (sizeByte > 0)
	{
		if (first_bit_Byte(byte))
			printf("1");
		else
			printf("0");
		print_Byte(byte << 1, sizeByte - 1);
	}
	else
		printf("\n");
}

bool first_bit_Byte(Byte byte)
{
	return byte >> 7;
}

void pop_back_Byte(Byte* byte)
{
	*byte = *byte << 1;
}

void add_empty_subTree(Tree tree, bool right)
{
	Tree newTree;
	init_Tree(&newTree);
	add_subTree(tree, newTree, right);
}

int indice_tableau_Binary(Binary elmt, Binary* tableau, size_t sizeTab)
{
	for (int i = 0; i < sizeTab; i++)
	{
		if (compar_Binary(tableau[i], elmt) == 0)
			return i;
	}
	return -1;
}

void read_forhead(FILE* input, size_t* sizeText, char* sizeTree, Value** caracsTree)
{
	fscanf(input, "%lu", sizeText);
	fscanf(input, "%c", sizeTree);
	int sizeT = (int) *sizeTree; 
	*caracsTree = malloc(sizeof(Value)*sizeT);
	for (int iCarac = 0; iCarac < sizeT; iCarac++)
		fscanf(input, "%c", (*caracsTree + iCarac));
}

void update_byte(Byte* byte, size_t* sizeByte, FILE* file)
{
	pop_back_Byte(byte);
	*sizeByte = (*sizeByte) - 1;
	if (*sizeByte == 0)
	{
		fscanf(file, "%c", byte);
		*sizeByte = (*sizeByte) + 8;
		//printf("sizeByte: %lu\n", *sizeByte);
	}
}

void reconstruct_Tree(FILE* input, Tree tree, Byte* byte, size_t* sizeByte, size_t sizeTree, size_t* nbLeaf, Value* caracsTree)
{
	if (*nbLeaf < sizeTree)
	{
		if (!first_bit_Byte(*byte))
		{
			update_byte(byte, sizeByte, input);
			
			add_empty_subTree(tree, false);
			reconstruct_Tree(input, tree->left, byte, sizeByte, sizeTree, nbLeaf, caracsTree);
			
			add_empty_subTree(tree, true);
			reconstruct_Tree(input, tree->right, byte, sizeByte, sizeTree, nbLeaf, caracsTree);
		}
		else
		{
			if (is_leaf_Tree(tree))
			{
				tree->couple.value = caracsTree[*nbLeaf];
				(*nbLeaf)++;
			}
			while (first_bit_Byte(*byte) && *nbLeaf < sizeTree)//tout ce qu'il y a aprÃ¨s un un est inutile (sauf si c'est le dernier 1 de la description...)
				update_byte(byte, sizeByte, input);
			update_byte(byte, sizeByte, input);
		}
	}
}

void write_body_uncompress(FILE* input, FILE* output, size_t sizeText, Binary* tableCorresp, size_t sizeTree ,Byte tamponLecture, size_t sizeTamponLecture)
{
	char caractere = '\0';
	Binary tamponCarac = zero_Binary();
	size_t nbCarac = 0;
	while (nbCarac < sizeText)
	{
		do
		{
			if (first_bit_Byte(tamponLecture))
				add_one_Binary(tamponCarac);
			else
				add_zero_Binary(tamponCarac);
			update_byte(&tamponLecture, &sizeTamponLecture, input);
		} while (indice_tableau_Binary(tamponCarac, tableCorresp, UCHAR_MAX) == -1);
		
		nbCarac++;
		caractere = indice_tableau_Binary(tamponCarac, tableCorresp, UCHAR_MAX);
		tamponCarac = zero_Binary();
		fprintf(output, "%c", caractere);
		printf("%c", caractere);
	}
}

void uncompress(FILE* input, FILE* output)
{
	size_t sizeText;
	char sizeTree;
	Value* caracs;
	
	read_forhead(input, &sizeText, &sizeTree, &caracs);
	
	size_t nbLeaf = 0;
	Tree tree;
	init_Tree(&tree);
	Byte byte;
	fscanf(input, "%c", &byte);
	byte = byte << 2;
	size_t sizeByte = 6;
	
	reconstruct_Tree(input, tree, &byte, &sizeByte, (size_t)sizeTree, &nbLeaf, caracs);
	
	Binary tableCorresp[UCHAR_MAX];
	for(int i=0; i< UCHAR_MAX; i++)
		init_Binary(tableCorresp+i);
	
	construct_table_corresp(tree, tableCorresp, caracs, sizeTree, 0, 0);
	
	write_body_uncompress(input, output, sizeText, tableCorresp, sizeTree , byte, sizeByte);
	
	destruct_Tree(&tree);
	free(caracs);
}
