#include <stdio.h>
#include <stdlib.h>
#include "compress.h"

#define CHAR_MAX 256

void print_tab_Couple(Couple* couples, int size)
{
	for (int iCouple = 0; iCouple < size; iCouple++)
		printf("%c: %lu\n", couples[iCouple].value, couples[iCouple].freq);
}

void init_freq(Couple* couples)
{
	for (int iCouple = 0; iCouple < CHAR_MAX; iCouple++)
		init_Couple(&couples[iCouple], 0, (char) iCouple);
}

int frequence(FILE* fichier, Couple* couples)
{
	FILE* copieFichier = fichier; //on effectue une copie du pointeur pour ne pas le modifier et avoir à ré-ouvrir le fichier
	char caract = 'a';
	int sizeFile = 0;
	while (!feof(copieFichier))
	{
		caract = fgetc(copieFichier);
		couples[(int)caract].freq += 1;
		sizeFile++;
	}
	
	return sizeFile;
}

void tri_Couple(Couple* couples)
{
	qsort(couples, CHAR_MAX, sizeof(Couple), compar_Couple);
}

void add_couple_List_Tree(List list, Couple couple)
//Ajoute un couple a une liste d'arbre
{
	Tree treeTampon;
	init_Tree(&treeTampon);
	treeTampon->couple = couple;
	
	puts("treeTampon add couple...:");
	print_Tree(treeTampon);
	
	add_List(list, treeTampon);
	
	puts("list add couple...");
	print_list_tree(list);
	
	destruct_Tree(&treeTampon);
}

size_t build_Tree(Couple* couples, Tree* tree)
{
	//on passe toutes les cellules ou la frequence est nulle
	int iCouple = 0;
	while (couples[iCouple].freq == 0)
		iCouple++;
	size_t sizeTree = CHAR_MAX - iCouple;
	
	//on transforme la liste de cellules en liste d'arbres a un noeud
	Tree trees[sizeTree];
	for(int iTree = 0; iTree < sizeTree; iTree++)
	{
		init_Tree(trees + iTree);
		couple_to_Tree(&(trees[iTree]), couples[iCouple + iTree]);
	}
	
	fusion_tab_Tree(trees, sizeTree);
	
	//On recupere le seul arbre de la liste qui est l'arbre fusionne
	*tree = trees[sizeTree - 1];
	
	return sizeTree;
}

void description_Tree(Tree tree, Binary description, Value** caracs)
{
	//print_hexa_Binary(description);
	if (tree != NULL)
	{
		if (is_leaf_Tree(tree))
		{
			**caracs = tree->couple.value;
			(*caracs)++;
		}
		
		add_zero_Binary(description); //ajouter un zero en fin de sequence binaire
		description_Tree(tree->left, description, caracs);
		
		if (!is_leaf_Tree(tree))
			add_one_Binary(description); //ajouteur un 1 en fin de sequence binaire
		
		description_Tree(tree->right, description, caracs);
		
		if (!is_leaf_Tree(tree))
			add_one_Binary(description); //ajouteur un 1 en fin de sequence binaire
	}
}

int indice_tableau(Value elmt, Value* tableau, size_t sizeTab)
{
	for (int i = 0; i < sizeTab; i++)
	{
		if (tableau[i] == elmt)
			return i;
	}
	return -1;
}

void construct_table_corresp(Tree tree, Binary output[CHAR_MAX], Value* caracs, size_t sizeTree, Byte codeCarac, size_t tailleCode)
{
	if (tree != NULL)
	{
		if (is_leaf_Tree(tree))
		{
			Binary code;
			init_fromByte_Binary(&code, &codeCarac, tailleCode);
			int iCarac = indice_tableau(tree->couple.value, caracs, sizeTree);
			output[iCarac] = code;
		}
		else
		{
			construct_table_corresp(tree->left, output, caracs, sizeTree, codeCarac << 1, tailleCode + 1);
			construct_table_corresp(tree->right, output, caracs, sizeTree, (codeCarac << 1) + 1, tailleCode + 1);
		}
	}
}

void mise_en_forme_description(Binary descriptionTree)
{	
	right_shift_Binary(descriptionTree, 2);
}

void write_forhead(FILE* output, size_t sizeText, size_t sizeTree, Value* caracs)
{
	fprintf(output, "%lu", sizeText);
	fprintf(output, "%c", (char)sizeTree);
	for (int iChar = 0; iChar < sizeTree; iChar++)
		fprintf(output, "%c", caracs[iChar]);
}

void write_body(FILE* input, FILE* output, Binary descriptionTree, Binary* tableCorresp, Value* caracs, size_t sizeTree)
{
	int indiceCarac = 0;
	Binary tamponBinary = descriptionTree;
	write_Binary(tamponBinary, output);
	
	do
	{
		char readCaractere;
		fscanf(input, "%c", &readCaractere);
		
		Binary binaryCaract;
		indiceCarac = indice_tableau(readCaractere, caracs, sizeTree);
		binaryCaract = tableCorresp[indiceCarac]; //caracs et tableCorresp sont ordonnés de la meme manière 
		
		concatenate_Binary(tamponBinary, binaryCaract);
		write_Binary(tamponBinary, output);
	} while (!feof(input));
	
	//on cloture alors le texte
	Binary zeroBinary = zero_Binary();
	
	while (tamponBinary != zeroBinary && tamponBinary->size < 8)
		add_zero_Binary(tamponBinary);
		
	fprintf(output, "%c", (char) 3);
	
	destruct_Binary(&zeroBinary);	
}

void compress(FILE* input, FILE* output)
{	
	Couple couples[CHAR_MAX];
	init_freq(couples);
	
	int sizeFile = frequence(input, couples);
	rewind(input);
	
	tri_Couple(couples);
	
	Tree tree;
	size_t sizeTree = build_Tree(couples, &tree);
	
	Binary descriptionTree = un_Binary();
	Value* caracs = malloc(sizeof(Value)*sizeTree);
	Value* parcoursCarac = caracs;
	description_Tree(tree, descriptionTree, &parcoursCarac); //établit la description de l'arbre et la liste (ordonnee) des caractères qui le compose
	
	mise_en_forme_description(descriptionTree); //retire les 3 derniers bits de description, et rajoute un 1

	Binary* tableCorresp = malloc(sizeTree*sizeof(Binary)); //va contenir la table de correspondance (caractère -> code de huffman)
	
	Byte codeCarac = (char) 1;
	
	construct_table_corresp(tree, tableCorresp, caracs, sizeTree, codeCarac, 1); //on construit la table de correspondance
	
	write_forhead(output, sizeFile, sizeTree, caracs);
	write_body(input, output, descriptionTree, tableCorresp, caracs, sizeTree);
	
	for(int i=0; i< sizeTree; i++)
		destruct_Binary(&(tableCorresp[i]));
	
	//print_Tree(tree);
	
	free(tableCorresp);
	free(caracs);
	destruct_Binary(&descriptionTree);
	destruct_Tree(&tree);
}
