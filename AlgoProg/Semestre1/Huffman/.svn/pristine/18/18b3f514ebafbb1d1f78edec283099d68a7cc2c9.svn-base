#include "tree.h"
#include "list.h"
#include <stdio.h>
#include <assert.h>

void init_void_Tree(void** tree)
{
	*(Tree*)tree = malloc(sizeof(struct Tree));
	init_Couple(&(*(Tree*)tree)->couple, 0, '\0');
	(*(Tree*)tree)->left = NULL;
	(*(Tree*)tree)->right = NULL;
}

void init_Tree(Tree* tree){
	init_void_Tree((void*)tree);
}

void destruct_Tree(void* tree)
{
	Tree* treeTree = (Tree*)tree;
	if(treeTree != NULL && *treeTree != NULL && !empty_Tree(*(treeTree)))
	{
		destruct_Tree((void*)(&((*treeTree)->left)));
		destruct_Tree((void*)(&((*treeTree)->right)));
		free(*treeTree);
		*treeTree = NULL;
	}
}

int compar_Tree(void* a, void* b)
{
	size_t freq_a = (*(Tree*)a)->couple.freq;
	size_t freq_b = (*(Tree*)b)->couple.freq;
	if (freq_a < freq_b)
		return -1;
	return (freq_a > freq_b);
		
}

bool empty_Tree(Tree tree)
{
	return tree == NULL;
}

int size_Tree(Tree tree)
{
	if (empty_Tree(tree))
		return 0;
	return 1 + size_Tree(tree->left) + size_Tree(tree->right);
}

bool has_key_Tree(Tree tree, int freq)
{
	if (empty_Tree(tree))
		return false;
	
	return tree->couple.freq == freq || has_key_Tree(tree->left, freq) || has_key_Tree(tree->right, freq);
}

bool is_leef_Tree(Tree tree)
{
	return tree->right == NULL && tree->left == NULL;
}

Value get_value_Tree(Tree tree, int freq)
{
	if (empty_Tree(tree))
		return (char)0;
	
	if (tree->couple.freq == freq)
		return tree->couple.value;
	
	return has_key_Tree(tree->left, freq) | has_key_Tree(tree->right, freq);
}

static void print_deep_Tree(Tree tree, size_t depth){
	for (int iDepth = 0; iDepth < depth*6; iDepth++)
			printf(" ");
	
	printf("(%lu) ", tree->couple.freq);
	if (tree->left != NULL){
		printf("\n\\--0--\n");
		print_deep_Tree(tree->left, depth + 1);
	}
	if (tree->right != NULL){
		printf("\n\\--1--\n");
		print_deep_Tree(tree->right, depth + 1);
	}
	if (is_leef_Tree(tree))
		printf("'%c'\n", tree->couple.value);
}

void print_Tree(Tree tree){
	if (empty_Tree(tree))
		printf("(0)\n");
	else {
		print_deep_Tree(tree, 0);
	}
}

void couple_to_Tree(Tree* tree, Couple couple)
{
	if (*tree != NULL)
		destruct_Tree(tree);
	*tree = malloc(sizeof(struct Tree));
	(*tree)->couple = couple;
	(*tree)->left = NULL;
	(*tree)->right = NULL;
}

void concatenate_Tree(Tree* dest, Tree source)
{
	Tree tree;
	init_Tree(&tree);
	tree->couple.freq =  (*dest)->couple.freq + source->couple.freq;
	tree->left = *dest;
	tree->right = source;
	*dest = tree;
}

void add_subTree(Tree father, Tree fils, bool right){
	if (right)
		father->right = fils;
	else
		father->left = fils;
}

void equal_Tree(void* dest, void* source)
{
	*(Tree*)dest = *(Tree*)source;	
}

void fusion_List_Tree(List listTree)
{
	while (listTree->cell->next != NULL)
	{
		concatenate_Tree((Tree*)(get_i_List(listTree, 1)), (*(Tree*)(front_List(listTree))));
		pop_front_List(listTree);
	}
}
