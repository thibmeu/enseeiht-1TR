#include <stdio.h>
#include <stdlib.h>
#include "compress.h"

#define CHAR_MAX 256

void init_freq(Couple* couples)
{
	for (int iCouple = 0; iCouple < CHAR_MAX; iCouple++)
		init_Couple(&couples[iCouple], 0, (char) iCouple);
}

int frequence(FILE* fichier, Couple* couples)
{
	char caract = 'a';
	int size_file = 0;
	while (!feof(fichier))
	{
		caract = fgetc(fichier);
		couples[(int)caract].freq += 1;
		size_file++;
	}
	return size_file;
}

void tri_Couple(Couple* couples)
{
	qsort(couples, CHAR_MAX, sizeof(Couple), compar_Couple);
}

int build_Tree(Couple* couples, Tree* tree){
	int iCouple = 0;
	int size_tree;
	List list;
	Tree tree_tampon;
	init_List(list, sizeof(tree), init_Tree, free, equal_Tree, compar_Tree);
	
	//on passe toutes les cellules ou la frequence est nulle
	while (couples[iCouple].freq == 0)
		iCouple++;
	size_tree = CHAR_MAX - iCouple;
	
	//on transforme la liste de cellules en liste d'arbres a un noeud
	while (iCouple < CHAR_MAX)
	{
		couple_to_Tree(&tree_tampon, couples[iCouple]);
		add_List(list, tree_tampon);
		iCouple++;
	}
	
	//tant que la liste contient plus d'un arbre, on fusionne
	while (list->cell->next != NULL)
	{
		switch (compar_Tree(list->cell->data, (list->cell->next)->data))
		{
			case -1:
				add_subTree(*((Tree*) list->cell->data), (Tree*) (list->cell->next)->data, FALSE);
			break
			case 0:
				Tree* new_tree = malloc(sizeof(Tree));
				init_Tree(new_tree);
				new_tree->couple.freq = 0;
				new_tree->couple.a
			break;
				
		}
		add_subTree(*((Tree*) list->cell->data), (Tree*) (list->cell->next)->data, /*Ajout a gauche ou a droite =????*/);
		pop_front_List(list); //Ã  faire
	}
	
	*tree = list->cell->data;
	
	return size_tree;
}

void description_Tree(Tree tree, Binary* description, Value* caracs, int iCarac)
{
	if (tree != NULL)
	{
		if (tree->left == NULL && tree->right == NULL) //fonction est_feuille
		{
			caracs[iCarac] = tree->couple.value;
			iCarac ++;
		}
		left_shift_Binary(description, 1);
		description_Tree(tree->left, description, caracs, iCarac);
		
		
		left_shift_Binary(description, 1);
		or_Binary(description, un_Binary());
		
		description_Tree(tree->left, description, caracs, iCarac);
	}
}

void write_forhead(FILE* entry, FILE* output, int size_txt, int size_tree, Value* caracs)
{
	fprintf(output, "%d", size_txt);
	fprintf(output, "%c", (char) size_tree);
	for (int iChar = 0; iChar < size_tree; iChar++)
		fprintf(output, "%c", caracs[iChar]);
}
