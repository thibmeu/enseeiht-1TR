#include "tree.h"
#include "list.h"
#include <stdio.h>
#include <assert.h>

void init_void_Tree(void** tree)
{
	*(Tree*)tree = malloc(sizeof(struct Tree));
	init_Couple(&(*(Tree*)tree)->couple, 0, '\0');
	(*(Tree*)tree)->left = NULL;
	(*(Tree*)tree)->right = NULL;
}

void init_Tree(Tree* tree){
	init_void_Tree((void*)tree);
}

void destruct_Tree(void* tree)
{
	Tree* treeTree = (Tree*)tree;
	if(treeTree != NULL && *treeTree != NULL && !empty_Tree(*(treeTree)))
	{
		if (!is_leaf_Tree(*treeTree))
		{
			destruct_Tree(&((*treeTree)->left));
			destruct_Tree(&((*treeTree)->right));
		}
		free(*treeTree);
		*treeTree = NULL;
	}
}

int compar_Tree(void* a, void* b)
{
	size_t freq_a = (*(Tree*)a)->couple.freq;
	size_t freq_b = (*(Tree*)b)->couple.freq;
	if (freq_a < freq_b)
		return -1;
	return (freq_a > freq_b);
		
}

bool empty_Tree(Tree tree)
{
	return tree == NULL;
}

int size_Tree(Tree tree)
{
	if (empty_Tree(tree))
		return 0;
	return 1 + size_Tree(tree->left) + size_Tree(tree->right);
}

bool has_key_Tree(Tree tree, int freq)
{
	if (empty_Tree(tree))
		return false;
	
	return tree->couple.freq == freq || has_key_Tree(tree->left, freq) || has_key_Tree(tree->right, freq);
}

bool is_leaf_Tree(Tree tree)
{
	return tree->right == NULL && tree->left == NULL;
}

Value get_value_Tree(Tree tree, int freq)
{
	if (empty_Tree(tree))
		return (char)0;
	
	if (tree->couple.freq == freq)
		return tree->couple.value;
	
	return has_key_Tree(tree->left, freq) | has_key_Tree(tree->right, freq);
}

static void print_tab(size_t n)
{
	for (int iTab = 0; iTab < n; iTab++)
		printf(" ");
}

static void print_deep_Tree(Tree tree, size_t depth)
{
	print_tab(depth);
	
	printf("(%lu)", tree->couple.freq);
	if (is_leaf_Tree(tree))
		printf(" '%c'\n", tree->couple.value);
	if (tree->left != NULL)
	{
		printf("\n");
		print_tab(depth+2);
		printf("\\--0--\n");
		print_deep_Tree(tree->left, depth+8);
	}
	if (tree->right != NULL)
	{
		if (tree->left == NULL)
			printf("\n");
		print_tab(depth+2);
		printf("\\--1--\n");
		print_deep_Tree(tree->right, depth+8);
	}
}

void print_Tree(Tree tree){
	if (empty_Tree(tree))
		printf("(0)\n");
	else {
		print_deep_Tree(tree, 0);
	}
}

void couple_to_Tree(Tree* tree, Couple couple)
{
	if (*tree != NULL)
		destruct_Tree(tree);
	init_Tree(tree);
	(*tree)->couple = couple;
}

void concatenate_Tree(Tree* dest, Tree source)
{
	Tree tree;
	init_Tree(&tree);
	tree->couple.freq =  (*dest)->couple.freq + source->couple.freq;
	tree->left = *dest;
	tree->right = source;
	*dest = tree;
	print_Tree(*dest);
}

void add_subTree(Tree father, Tree fils, bool right)
{
	if (right)
		father->right = fils;
	else
		father->left = fils;
}

void equal_Tree(void* dest, void* source)
{
	*(Tree*)dest = *(Tree*)source;	
}

void fusion_List_Tree(List listTree)
{
	while (listTree->cell->next != NULL)
	{
		concatenate_Tree((Tree*)get_i_List(listTree, 1), *(Tree*)front_List(listTree));
		pop_front_List(listTree);
	}
}
