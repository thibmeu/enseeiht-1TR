/*********************************************************************
**  Auteurs  : 
**  Objectif : 
*********************************************************************/
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>
#include <stdbool.h>
#define NB_CARTES 52
#define NB_ENSEIGNES 4
#define NB_VALEURS 13
#define NB_COULEURS NB_ENSEIGNES/2
#define NB_ETAPES 2
#define NB_CARTES_ETOURDI 10
#define TAILLE_LIGNE 3
#define TAILLE_COLONNE 6
#define DECALAGE 1
#define MAX_NOM 100
#define MIN_JOUEURS 1000
#define MAX_JOUEURS 1000
#define NB_LIGNES NB_ENSEIGNES
#define NB_COLONNES NB_VALEURS
#define NB_LIGNES_AFFICHAGE NB_LIGNES*TAILLE_LIGNE+1 + 2*DECALAGE
#define NB_COLONNES_AFFICHAGE NB_COLONNES*TAILLE_COLONNE+1 + 2*DECALAGE
#define NB_ETATS_CARTE 3
#define NB_IA 3

const char txtEnseigne[NB_ENSEIGNES][TAILLE_LIGNE] = {"PIQ", "COE", "CAR", "TFL"};
const char txtValeur[NB_VALEURS][TAILLE_LIGNE] = {"AS ", " 2 ", " 3 ", " 4 ", " 5 ", " 6 ", " 7 ", " 8 ", " 9 ", "10 ", "VLT", "DME", "ROI"};

enum Enseigne {Pique, Coeur, Carreau, Trefle};
typedef enum Enseigne Enseigne;
enum Valeur {As, Deux, Trois, Quatre, Cinq, Six, Sept, Huit, Neuf, Dix, Valet, Dame, Roi};
typedef enum Valeur Valeur;
enum Difficulte{NAIF, EXPERT, ETOURDI};
typedef enum Difficulte Difficulte;
enum EtatCarte {VISIBLE, CACHEE, RETIREE};
typedef enum EtatCarte EtatCarte;

const char affEtatCarte[NB_ETATS_CARTE][TAILLE_LIGNE][TAILLE_COLONNE] =
	{{"???", "???"},	//VISIBLE --> INCONNU
	 {"~~~", "~~~"},	//CACHEE
	 {"   ", "   "}};	// RETIREE

struct Position
{
	int ligne;
	int colonne;
};
typedef struct Position Position;

const Position memoireVide = {-1, -1};

struct Carte
{
	Enseigne enseigne;
	Valeur valeur;
};
typedef struct Carte Carte;

void init_Carte(Carte* carte, Enseigne enseigne, Valeur valeur)
{
	(*carte).enseigne = enseigne;
	(*carte).valeur = valeur;
};

typedef Carte Jeu52 [NB_CARTES];

void init_Jeu52(Jeu52 jeu)
{
	for(int iEnseigne = 0; iEnseigne < NB_ENSEIGNES; iEnseigne++)
		for(int iValeur = 0; iValeur < NB_VALEURS; iValeur++)
		{
			Carte iCarte = {iEnseigne, iValeur};
			*(jeu+iEnseigne*NB_VALEURS+iValeur) = iCarte;
		}
}

struct CarteReele
{
	Carte carte;
	EtatCarte etat;
};
typedef struct CarteReele CarteReele;

typedef CarteReele Tapis [NB_ENSEIGNES][NB_VALEURS];

struct Joueur
{
		char nom[MAX_NOM];
		bool humain;
		Difficulte difficulte;//Si le joueur est virtuel vaut NULL
		Position memoire[NB_CARTES]; //initialiser a {-1,-1} == memoire vide
		int score;
};
typedef struct Joueur Joueur;

void init_Joueur(char nom[MAX_NOM], bool humain, Difficulte difficulte, Position memoire[NB_CARTES], int score, Joueur *joueur)
{
	for (int iChar = 0; iChar < MAX_NOM; iChar++)
		joueur->nom[iChar] = nom[iChar];
	joueur->humain = humain;
	joueur->difficulte = difficulte;
	for (int iPosition = 0; iPosition < NB_CARTES; iPosition++)
		joueur->memoire[iPosition] = memoire[iPosition];
	joueur->score = score;
}

//
//Debut des fonctions de Jeu52
//

void clear_stdin()
{ 
  while ( getchar() != '\n' );
}

void permuter(Jeu52 jeu)
{
	int iCarte1 = rand()%NB_CARTES;
	int iCarte2 = rand()%NB_CARTES;
	Carte temp = *(jeu+iCarte1);
	*(jeu+iCarte1) = *(jeu+iCarte2);
	*(jeu+iCarte2) = temp;
}

void battre(Jeu52 jeu)
{
	const int NB_BATTUES = 10*1000;
	for(int iBattue = 0; iBattue < NB_BATTUES; iBattue++)
		permuter(jeu);
}

void calculPosCartes(Jeu52 jeu, int posCarte[NB_CARTES])
{
	for(int iCarte = 0; iCarte < NB_CARTES; iCarte++)
	{
		int iEnseigne = (*(jeu+iCarte)).enseigne;
		int iValeur = (*(jeu+iCarte)).valeur;
		posCarte[iEnseigne*NB_VALEURS+iValeur] = iCarte;
	}
	
}

void affichage(Jeu52 jeu)
{
	int posCarte[NB_CARTES];
	calculPosCartes(jeu, posCarte);
	for(int iCarte = 0; iCarte < NB_CARTES; iCarte++)
		printf("%d ", posCarte[iCarte]);
	puts("");
}

bool bienBattu(Jeu52 jeu)
{
	int posCarte[NB_CARTES];
	calculPosCartes(jeu, posCarte);
	for(int iCarte = 0; iCarte < NB_CARTES-1; iCarte++)
		if ((posCarte[iCarte]+1 == posCarte[iCarte+1]) || posCarte[iCarte] < 0 || posCarte[iCarte] >= NB_CARTES)
			return false;
	return (posCarte[NB_CARTES-1] < NB_CARTES && posCarte[NB_CARTES-1] >= 0);
}
//
//Fin des fonctions de Jeu52
//

void init_Tapis(Tapis tapis)
{
	Jeu52 jeu;
	init_Jeu52(jeu);
	battre(jeu);
	for(int iEnseigne = 0; iEnseigne < NB_ENSEIGNES; iEnseigne++)
		for(int iValeur = 0; iValeur < NB_VALEURS; iValeur++)
			tapis[iEnseigne][iValeur] = jeu[iEnseigne*NB_VALEURS+iValeur];
}

bool isEgalesCartes(Carte c1, Carte c2)
{
	return (c1.enseigne == c2.enseigne) && (c1.valeur == c2.valeur);
}

bool isEgalesPositions(Position a, Position b)
{
	return (a.ligne == b.ligne) && (a.colonne == b.colonne);
}

CarteReele tapisPosition(Tapis tapis, Position position)
{
	return tapis[position.ligne][position.colonne];
}

void setPosition(Position b, Position* this)
{
	this->ligne = b.ligne;
	this->colonne = b.colonne;
}

void stockageMemoireJoueur(Tapis tapis, Position memoire[NB_CARTES], Position carte, Difficulte difficulte)
{
	int iMemoire = 0;
	while (iMemoire < NB_CARTES && isEgalesPositions(memoire[iMemoire], memoireVide))
	{
		if (isEgalesCartes(tapisPosition(tapis, memoire[iMemoire]).carte, tapisPosition(tapis, carte).carte))
			return;
		iMemoire++;
	}
	
	switch (joueur.difficulte)
	{
		case EXPERT:
		{
			if (iMemoire < NB_CARTES)
				setPosition(carte, &memoire[iMemoire]);
			break;
		}
		case ETOURDI:
		{
			if (iMemoire < NB_CARTES_ETOURDI)
				setPosition(carte, &memoire[iMemoire]);
			else if (iMemoire < NB_CARTES)
			{
				iMemoire = rand()%NB_CARTES_ETOURDI; //on remplace une carte au hasard dans la memoire
				setPosition(carte, &memoire[iMemoire]);
			}
		}
	}
}

void memoriseCarte(Tapis tapis, Joueur joueur, Position carteRetournee[NB_ETAPES])  //a completer
{
	if (!joueur.humain)
	{
		switch (joueur.difficulte)
		{
			case NAIF:
				break;
			case EXPERT, case ETOURDI: 
			{
				for(int iCarte = 0; iCarte < NB_ETAPES; iCarte++)
					stockageMemoireJoueur(tapis, joueur.memoire, carteRetournee[iCarte], joueur.difficulte);
				break;
			}
		}
	}
}

void affichageTapis(char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE])
{
	for(int iLigne = 0; iLigne < NB_LIGNES_AFFICHAGE; iLigne++)
	{
		for (int iColonne = 0; iColonne < NB_COLONNES_AFFICHAGE; iColonne++)
			printf("%c", affTapis[iLigne][iColonne]);
		printf("\n");
	}
}

void init_affTapis(char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE])
{
	//On pose les numeros des lignes ...
	for(int iLigne = 0; iLigne < NB_LIGNES_AFFICHAGE; iLigne++)
	{
		char bordure = (iLigne != 0 && iLigne%TAILLE_LIGNE == 0) ?'0'+(iLigne%TAILLE_LIGNE) : ' ';
		affTapis[iLigne][0] = bordure;
		affTapis[iLigne][NB_COLONNES_AFFICHAGE-1] = bordure;
	}
	//... puis des colonnes
	for(int iColonne = 0; iColonne < NB_COLONNES_AFFICHAGE; iColonne++)
	{
		char bordure = ((iColonne-4)%TAILLE_LIGNE == 0) ?'A'+((iColonne-4)%TAILLE_LIGNE) : ' ';
		affTapis[0][iColonne] = bordure;
		affTapis[NB_LIGNES_AFFICHAGE-1][iColonne] = bordure;
	}
	
	//On met maintenant toutes les cartes faces retournees
	for(int iLigne = 1; iLigne < NB_LIGNES_AFFICHAGE; iLigne++)
	{
		if(iLigne%TAILLE_LIGNE == 1)
		{
			for(int iColonne = 0; iColonne < NB_COLONNES_AFFICHAGE; iColonne++)
				affTapis[iLigne][iColonne] = (iColonne == iLigne) ? '+' : '-';
		}
		else
		{
			for(int iColonne = 1; iColonne < NB_COLONNES_AFFICHAGE; iColonne++)
				*(*(affTapis+iLigne)+iColonne) = "| ~~~ "; //attention, c'est faux
			affTapis[iLigne][NB_COLONNES_AFFICHAGE-DECALAGE-1] = '|';
		}
	}
}

void init_tab_joueur(Joueur joueur[MAX_JOUEURS], int* nbJoueurs)
{
	*nbJoueurs = -1;
	do
	{
		switch (*nbJoueurs)
		{
			
			case -1:
			{
				printf("A combien voulez vous jouer ? (entre %d et %d)\n", MIN_JOUEURS, MAX_JOUEURS);
				scanf("%d", nbJoueurs);
				break;
			}
			case 0:
			{
				printf("Il est impossible de jouer sans joueur\n");
				*nbJoueurs = -1;
				break;
			}
			case 1:
			{
				printf("Il est impossible de jouer seul\n");
				*nbJoueurs = -1;
				break;
			}
			case default:
			{
				printf("Entrez un nombre de joueurs valide !\n");
				*nbJoueurs = -1;
			}
		}
	} while (*nbJoueurs < MIN_JOUEURS && *nbJoueurs > MAX_JOUEURS);
	
	for(int iJoueur = 0; iJoueur < *nbJoueurs; iJoueur++)
	{
		printf("Configuration du joueur %d\n", iJoueur+1);
		
		//on prend son nom
		char nom[MAX_NOM];
		int iLettre;
		do
		{
			clear_stdin();
			iLettre = 0;
			printf("Entrez le nom du joueur (taille maximale : %d)\n", MAX_NOM);
			do
			{
				scanf("%c", &nom[iLettre]);
				iLettre++;
			} while (iLettre != '\n' && iLettre < MAX_NOM); //on autorise les ' '
		} while (iLettre >= MAX_NOM);
		
		//on choisit si le joueur est humain
		bool humain;
		char isHumain = 0;
		do
		{
			if (isHumain != 0)
				printf("Veuillez entrer 'o' ou 'n'");
			clear_stdin();
			printf("Le joueur sera-t-il humain ? (o/n)\n");
			scanf("%c", &isHumain);
		} while (isHumain != 'o' || isHumain != 'n');
		humain = (isHumain == 'o');
		
		//si le joueur est un ordinateur, on entre sa difficulte
		Difficulte difficulte;
		if (!humain)
		{
			int niveau = -1;
			do
			{
				if (niveau == -1)
					printf("Merci de reessayer, ia selectionnee non valide\n");
				printf("Entrer la difficulte de l'IA desiree (NAIF=0, EXPERT=1, ETOURDI=2)\n");
				scanf("%d", &niveau);
			} while (niveau < 0 || niveau >= NB_IA);
			difficulte = niveau;
		}
		
		//on fixe sa memoire a vide
		Position memoire[NB_CARTES];
		for (int iCase = 0; iCase < NB_CARTES; iCase++)
			setPosition(memoireVide, &memoire[iCase]);
		
		//score initialement nul
		int score = 0;
		init_Joueur(nom, humain, difficulte, memoire, score, &joueur[iJoueur]);
	}
}

void initialisation(Tapis tapis, char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE], Joueur joueur[MAX_JOUEURS], int* nbJoueurs)
{
	init_Tapis(tapis);
	init_affTapis(affTapis);
	init_tab_joueur(joueur, nbJoueurs);
}

void affichageVainqueurs(Joueur joueur[MAX_JOUEURS], int nbJoueurs)
{
	;
}

void placeCarte(char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE], char affCarte[TAILLE_LIGNE][TAILLE_COLONNE], Position position)
{
	for(int iLigne = position.ligne; iLigne < position.ligne+TAILLE_LIGNE; iLigne++);
}

void changementCarte(Tapis tapis, char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE], Position position, EtatCarte etat)
{
	char affCarte[TAILLE_LIGNE][TAILLE_COLONNE];  //Correspond à un emplacement de carte dans le tableau d'affichage
	CarteReele carte = tapisPosition(tapis, position);
	switch (etat){
		case VISIBLE:
			affCarte[0] = txtValeur[carte.carte.valeur];
			affCarte[1] = txtValeur[carte.carte.enseigne];
			tapis[position.ligne][position.colonne].etat = VISIBLE;
			break;
		
		case CACHEE:
			affCarte = affEtatCarte[CACHEE];
			tapis[position.ligne][position.colonne].etat = CACHEE;
			break;
			
		case RETIREE:
			affCarte = affEtatCarte[RETIREE];
			tapis[position.ligne][position.colonne].etat = RETIREE;
			break;
	}
	placeCarte(affTapis, affCarte, carte.position);
}

Position lecturePosition()
{
	Position position;
	char lettreColonne;
	int testScan = 0;
	bool testLigneColonne;
	printf("Entrez la position (ex: 1A)\n");
	while ( testScan =! 2 && testLigneColonne)
	{
		testLigneColonne = 0;
		clear_stdin();
		testScan = scanf(" %d %c ", &position.ligne, &lettreColonne);
		position.colonne = int(toupper(lettreColonne))- 65;
		if (position.ligne >= 0 && position.ligne =< NB_ENSEIGNES)
			if (position.colonne >= 0 && position.colonne =< NB_VALEURS)
				testLigneColonne = 1;
	}
	return position;
}

Position saisieCarte(Tapis tapis, Joueur joueur)
{
	Position position;
	if (joueur.humain)
	{
		do
		{
			position = lecturePosition();
		} while(tapis[position.ligne][position.colonne].etat =! RETOUNEE);
	}
	else
	{
		
	}
	return position;
}

void choixDesCartes(Tapis tapis, Position carteRetournee[NB_ETAPES], char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE], Joueur joueur)
{
	for(int iEtape=0; iEtape<NB_ETAPES; iEtape++)
	{
		affichageTapis(affTapis);
		carteRetournee[iEtape] = saisieCarte(tapis, joueur);
		changementCarte(tapis, affTapis, carteRetournee[iEtape], VISIBLE);
	}
}

bool couleurCarte(Carte c) //si true --> rouge
{
	return (((c.enseigne+1)/2)%2 == 1);
}

bool isPaireCarte(Carte c1, Carte c2)
{
	return (couleurCarte(c1) == couleurCarte(c2)) && (c1.valeur == c2.valeur);
}

void tourJoueur(Tapis tapis, char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE], Joueur joueur[MAX_JOUEURS], int nbJoueurs, int *iJoueur)
{
	Position carteRetournee[NB_ETAPES];
	choixDesCartes(tapis, carteRetournee, affTapis, joueur[iJoueur]);
	affichageTapis(affTapis);
	
	for (int jJoueur = 0; jJoueur < nbJoueurs; jJoueur++)   //Tous les joueurs memorisent la carte chacun à leur tour
		memoriseCarte(tapis, joueur[jJoueur], carteRetournee);
		
	Carte carte1 = tapis[carteRetournee[0].ligne][carteRetournee[0].colonne].carte;
	Carte carte2 = tapis[carteRetournee[1].ligne][carteRetournee[1].colonne].carte;
	if (isPaireCarte(carte1, carte2))
	{
		for(int iEtape = 0; iEtape < NB_ETAPES; iEtape++)
			changementCarte(tapis, affTapis, carteRetournee[iEtape], RETIREE); //On retire les deux cartes
		joueur[*iJoueur].score += 1;
		*iJoueur -= 1;  //On décrémente l'identificateur du joueur en cour de tel sorte que le joueur suivant a jouer soit lui même
	}
	else
	{
		for(int iEtape = 0; iEtape<NB_ETAPES; iEtape++)
			changementCarte(tapis, affTapis, carteRetournee[iEtape], CACHEE);
	}
}

bool testTapis(int nbCartesRestantes) //Test si le tapis est vide
{
	return (nbCartesRestantes == 0);
}

void partie(Tapis tapis, char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE], Joueur joueur[MAX_JOUEURS], int nbJoueurs)
{
	int iJoueur = rand()%nbJoueurs;
	int nbCartesRestantes = NB_CARTES;
	while (testTapis(nbCartesRestantes))
	{
		tourJoueur(tapis, affTapis, joueur, nbJoueurs, &iJoueur);
		iJoueur = (iJoueur + 1)%nbJoueurs;
	}
}

void jouerMemory()
{
	//_Mise en place du jeu
	Tapis tapis;
	char affTapis[NB_LIGNES_AFFICHAGE][NB_COLONNES_AFFICHAGE];
	Joueur joueur[MAX_JOUEURS];
	int nbJoueurs;
	
	initialisation(tapis, affTapis, joueur, &nbJoueurs);
	partie(tapis, affTapis, joueur, nbJoueurs);
	affichageVainqueurs(joueur, nbJoueurs);
}

int main()
{
	jouerMemory();
	
	return EXIT_SUCCESS;
}
